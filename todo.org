#+TODO: TODO(t) WAITING(w) IN-PROGRESS(p) WONTFIX(w) DONE(d)

* Compiler frontend
** TODO Compiler flags
*** DONE Optimization
*** DONE Output
*** TODO Different backends (when implemented)
    Which backends
*** DONE Data array size/start position, infinite array/cell size
* TODO Compiler backend
** DONE Add support for different int-sizes
** TODO Add arbitrary-size integer runtime support (gmp)
** DONE Configurable data array size
** TODO [#C] Configurable target-machine properties
   Not hardcoded to x86-64, no hard-coded size_t
* TODO Tests and benchmarks
** IN-PROGRESS Hspec tests for compiler.
*** Test various codegen options
**** TODO Different size cells
     - [ ] i8 
     - [ ] i32
     - [ ] i64
**** TODO Different size array
     - [ ] 30000 (default)
     - [ ] Really big ones
     - [ ] Really small ones
** IN-PROGRESS QuickCheck tests for parser of IR
*** DONE Making sure valid programs stay valid going from plain instructions to BFIR
*** DONE Splitting and rejoining BFIR in random position is idempotent
* TODO Optimizing compiler 
** TODO Optimizer pipeline structure
** TODO Improve IR
*** DONE [#A] Fix IR concatenation, it does not take advantage of invariants
    An IR sequence should always be minimal, so concatenating two
    sequences should only have to look at the two middle elements, not
    recurse on either sequence.
*** TODO Modify and move can be merged to a single instruction
*** TODO Set instead of modify when cell value is known
*** TODO Cell offset when we have a known cell index
** TODO Static analysis
*** TODO Dead code elimination
**** DONE Dead loops (known zero cell at start)
     - Start of program
     - Immediately after another loop
**** TODO Useless code at end of program
     Anything after the last IO operation is pointless
* [#C] Interpreter improvements
** Design for external manipulation
   Current design works for running a program from start to finish.
   A debugger would want to update the program underway (costly
   updates is ok).
   
* [#C] Debugger
** TODO Debugging UI
*** Proposed design:
    - Split screen top/bottom, instructions displayed on top, data on
      bottom. Ex:

            Current instruction
                    |
      {<-}  -->--]> v >>[+++.] {->}
      >>++.[<+++>-](-)---[>,+++++<]
      00 00 00 02 (f3) a2 92 00 00
      00 00 00 00  ^   00 00 00 00
      00 00 00 00  |   00 00 00 00
             Current data

      The instructions are displayed as if on a "tape" being fed in
      from the top left corner and going out the top right corner.
      The current instruction is in the "read" position in the middle
      of the screen, right above the "read" position of the data
      tape. The next instructions continue on the right until they
      reach the edge of the screen, then they wrap to the middle of
      the screen on the line above. They continue until the end of the
      instructions or they reach the top right corner. The
      instructions prior to the current flow similarly, but to the
      left instead. With @n being a portal to the other @n, the flow
      looks like:

        >  >  >  >@1 @4>  >  >  >
      @1>  >  >  >@2 @3>  >  >  >@4
      @2>  >  >  > (%) >  >  >  >@3

      Data flows similarly, but on the bottom half of the screen.

** TODO [#C] Requires new interpreter:
*** TODO Moving data pointer and instruction pointer forwards and backwards
*** TODO Live-editing instructions
*** TODO Time-traveling debugger
